---
title: 模型考古学（七）：Qwen2.5-Omni技术报告解读
published: 2025-03-27
description: "阿里小开了一款大模型，叫Qwen2.5-Omni，本篇将看下Qwen2.5-Omni的技术报告，讨论一下其中的创新点和Omni类模型的工程优势。"
image: "https://blog-1302893975.cos.ap-beijing.myqcloud.com/pic/202503271808335.png?imageSlim"
tags: ["模型考古学"]
category: 深度学习
draft: false
---
3月27日凌晨，阿里正式开源Qwen2.5-Omni，作为阿里首个开源的统一端到端模型，能处理文本、音频、图像和视频等多种模态，并生成实时的文本或语音响应。

以4o和minicpm-2.6o还有Qwen2.5-Omni为代表的全模态模型最突出的特点，是**以一个统一的 Transformer 体系来完成从感知到生成的全部环节**。它不仅支持多模态信息的输入和理解，还能根据需要，以文本或语音这两种形式进行流式输出。这在实际应用中格外有价值：例如在语音对话场景里，Qwen2.5-Omni 可以先用音频编码器接收和理解用户的口头指令，再通过语言解码器（文本输出）或双轨自回归生成器（语音输出）提供实时响应；而在视频对话中，它则能将图像、语音等要素统一编码，解决视频理解、人物说话内容识别与场景描述等一系列“跨模态语义融合”的难题。

> 当然，4o面向c端解锁的全模态能力是渐进式的。可能刚发布时只有个处理图片和文本，下个月支持处理音频，再过几个月终于支持输出图像+音频了，主打一个切香肠。
> 

从命名上看，“Omni”一词本身就象征了“全能”与“全局性”。而与之前的多模态大模型相比，Qwen2.5-Omni 选择了用一个“端到端”的思路来彻底打通模态之间的传递过程，让模型能够在同一条工作流中接收、处理和输出多模态信息。**这意味着很多过去需要将语音识别、视觉编码、文本生成等环节分离处理，再通过繁琐的中间表示或接口进行整合的做法，目前都可以由单个模型来进行处理，整体流程的复杂度极大的被降低**。

回到主题，我们之所以关注这款新模型，正是因为它向我们展示了统一端到端多模态模型的潜力和挑战。从Openai的GPT-4o，谷歌的Gemini系列，再到现在的qwen2.5-omni，我们可以看到学术产业界正在不断尝试把大模型的“通用性”往更多样化的模态延伸，Qwen2.5-Omni 则进一步证明了当多模态感知与多模态生成深度耦合、在同一套序列建模体系内协同演化时，将可能为各行各业带来更多交互方式、更大创新空间。

Qwen2.5‑Omni 的关键特性可以概括为：

- 总体来说，这是一个可以感知所有模态并能以流式方式同时生成文本和自然语音响应的统一模型
- 研究团队提出了一种新的位置嵌入算法，称为TMRoPE，该算法明确地融入了时间信息以同步音频和视频
- 研究团队提出了Thinker‑Talker 架构，以促进实时理解和语音生成

接下来，我们会结合官方技术报告，对 Qwen2.5-Omni 的架构设计、训练过程以及在不同基准下的性能表现，做更细致的拆解与点评。毕竟，对于一款“真的能听、能看、能说、能生成”的模型，了解它的内部机理与实现思路，才是真正的“模型考古学”最有趣的部分。

# 一、构建全模态模型的难度是什么？

## 1.多模态统一训练的复杂性

在现实世界中，各个模态（文本、图像、语音和视频等）的数据分布和特征形式大不相同。传统大模型最喜欢的文本模态是离散符号序列，音频则更关注短时频谱动态，图像/视频有二维甚至三维时空结构。想要把这些模态放到同一个模型中进行端到端的统一训练，**首先就需要面对大规模的数据标签风格和模态差异带来的对齐问题**。所以，模型必须具备一种“系统性方法”来实现图像-文本、视频-文本、音频-文本等对齐，这既要求模型本身具备足够灵活的结构，也需要能够在训练阶段让所有模态“互相促进”，而不是各管各的。

更进一步，如果将多模态特征全部简单拼接在一起，很可能导致不同模态之间互相干扰，甚至把原本在各模态上已学到的特征能力“破坏”掉。为了克服这一难点，Qwen2.5-Omni 会在模型结构和训练数据上进行特别设计，例如先通过大量单模态或双模态对齐数据进行预训练，再逐步纳入更大规模的多模态混合数据等。

## 2.时间同步与多维位置编码

音频、视频都具有时间维度，**并且二者需要对齐以保证“所见即所听”**。如果在时间轴上对它们进行不当处理，一方面容易损失视频时序或音频节奏信息，另一方面还会造成语音与视频帧不同步。报告里提出的一大创新是 TMRoPE（Time-aligned Multimodal Rotary Position Embedding），**通过对输入序列做“时间切块+多维位置编码”，在 40ms 这一相对统一的时间粒度下，让音频帧和视频帧逐步匹配**。加之对图像、视频的高度与宽度位置编码进行区分，最终在单一的 Transformer 模型里实现了多模态时空信息的对齐与融合。

对于不同帧率的视频，Qwen2.5-Omni 也会通过动态插值、块状处理等策略来减少长序列带来的内存开销，进而实现实时处理，保证了多模态编码器不会因为“时序过长”而失效。

## 3.同时生成多模态输出的相互干扰

与常见的“多模态输入、单模态输出”不同，Qwen2.5-Omni 还要能在输出侧同时生成文本和语音，并且是以流式的方式生成，这里另一个难点就出现了：**如何避免文本和语音在解码过程中的相互干扰？**

报告中专门提出了 Thinker-Talker 架构：

- *Thinker* 相当于“语言大脑”，进行高层的语言思考、生成文本，并提供抽象的语义向量给到后续。
- *Talker* 则只关注如何把 Thinker 的这些高维语义表示转成语音编码，并进一步流式输出音频。

通过这样的解耦，模型能在同一套流水线（同一个 Transformer）里，并行完成“文本思考”和“语音生成”两件事，不至于出现语音编码和文本编码在输出层互相“污染”的问题；同时还能根据用户需求，决定用文字还是语音来回复，也可以两者都输出。

在其他多模态模型里，如果直接共享一个单一解码器输出多模态，极易导致参数竞争、梯度冲突，从而影响整体生成质量。

## 4.全模态模型在流式场景下对模型结构和推理效率的高要求

要支持实时语音对话或视频对话，单纯解决输入和输出的模态融合并不够，还得兼顾“延迟”——尤其是语音、视频数据量大，且往往需要连续接收和生成。如果仍使用传统的全局注意力机制去处理几分钟甚至更长的音视频序列，模型规模和计算量都会成倍飙升。

为此，Qwen2.5-Omni 在多模态编码器上采用了“块状（block-wise）”或“滑动窗口”的注意力机制，对长序列进行分块处理；又在生成端使用了分段自回归的方式（双轨自回归 + Streaming DiT），能在相对有限的上下文内完成一段语音的生成，再与下一个音频块顺畅衔接，减少初始包时延。这些设计都是为了真正做到“边输入边输出”，而不是一次性拿到所有音视频后再统一推理。

# 二、Thinker-Talker 解读

![](https://blog-1302893975.cos.ap-beijing.myqcloud.com/pic/202503271807672.png?imageSlim)

上图为Qwen2.5-Omni的架构，可以看到Qwen2.5‑Omni 采用了 Thinker‑Talker 架构。Thinker 就像大脑一样，负责处理和理解来自文本、音频和视频模态的输入，生成高级表示和相应的文本。Talker 则像人的嘴巴一样，以流式的方式接收 Thinker 产生的高级表示和文本，并以离散的语音单元输出。

## 1.Thinker模块：负责理解与文本生成

Thinker模块本身就可以被视为一个大语言模型（LLM），用来接收来自多种模态的输出（文本、图像、音频、视频），将这些信息转化为高层语义表示。在在输入端，Thinker 通过一系列编码器（Audio Encoder、Vision Encoder）获取语音、图像 / 视频的表示，再和文本序列的表示在统一的 Transformer 解码器中融合。不同模态在实际处理时，通过 **TMRoPE** 等时间对齐机制确保时序信息一致，从而让 Thinker 能获得对多模态的整体理解。

![](https://blog-1302893975.cos.ap-beijing.myqcloud.com/pic/202503271841602.png?imageSlim)

当用户需要纯文本回答时，Thinker 就直接把语义向量转化为文本输出（经典的自回归生成过程）。从架构上看，它承担了大部分复杂的“语言思考”和 “语义推理”工作。

## 2.Talker模块：负责语音生成

- **“嘴巴”角色，双轨自回归**
    
    Talker 采用了 **dual-track autoregressive** 方式，专门针对语音生成而设计。它在训练和推理过程中，会和 Thinker 同步进行，但只需要关注如何将 Thinker 的高维语义表示转换成音频编码再合成语音。
    
    Talker模块会接收来自 Thinker 采样文本标记的高层表示和嵌入。作为一种流式算法，语音生成必须在整个文本完全生成之前预测内容的声音和态度。Thinker 提供的高维表示隐式传达了此类信息，从而实现更自然的流式生成过程。
    
    Qwen团队还设计了一种高效的语音编解码器 qwen‑tts‑tokenizer。qwen‑tts‑tokenizer 能够高效地表示语音的关键信息，并且可以通过因果音频解码器流式地解码为语音流。接收信息后，说话者开始自回归地生成音频标记和文本标记。语音生成不需要与文本在词级和时标级上进行对齐。这显著简化了训练数据和推理过程的要求。
    
- **融合文本 token 与高维向量**
    
    语音生成并非仅依赖 Thinker 的隐藏语义表示——报告中提到，为了让模型在需要实时输出、并且可能有丰富情感或语气时能生成更自然的声音，Talker 还会拿到一部分实际采样出的文本 token 作为参考，以消解同音词、语义模糊等问题，保证与文本意义相匹配的音频生成。
    
- **Streaming DiT 实现流式语音输出**
    
    Talker 输出的语音编码最终会通过后端的 DiT（Diffusion Transformer）模块生成音频波形，而这个环节采用了“滑动窗口”分块处理，用相对有限的上下文就能持续生成音频，减少延迟，这也是整个系统能支持“边录音、边回复”的关键。
    

:::note
在初始预训练阶段，Qwen2.5-Omni的LLM组建用的是Qwen 2.5，视觉编码器与Qwen2.5-VL相同，音频编码器则使用Whisper-large-v3进行初始化。
:::

# 三、跑分展示

![](https://blog-1302893975.cos.ap-beijing.myqcloud.com/pic/202503271859412.png?imageSlim)

剩下的懒得放了，毕竟7B的模型最主要还是学术研究用途。

# 总结

Qwen2.5-Omni 作为一款真正意义上的多模态统一模型，它最核心的价值在于极大地简化了多模态处理和生成的工作流程。传统模式下，文本、图像、语音、视频往往需要分别调用专门模型或工具，再借助各种中间接口才能完成。每多一种模态，往往就会增加一层繁琐的对接和管理成本。而 Qwen2.5-Omni 将多模态感知与多模态生成整合在同一个端到端模型里：

1. **一次性完成感知到表达**
    
    无论输入是音频、图像、视频还是文本，所有预处理、解析和编码都在同一个大的架构内完成，免去了在不同模型之间拆分和转换数据格式的步骤。
    
2. **流式输出让互动更高效**
    
    Qwen2.5-Omni 不仅能输出文本，也能在同一个模型内同步地生成语音响应，这种“边听边说”的对话模式极大地提升了实时交互体验。工作流层面，无需再为“文本转语音”单独部署 TTS 引擎，减少了对接流程和延迟。
    
3. **训练与维护集中化**
    
    过去用多模态方案时，**常要分别维护语音识别、视觉模型、语言模型、TTS 模块等四五个组件**；**而一个统一的 Omni 模型集中管理了多模态的能力更新，降低了系统复杂性**。训练或更新时，一次性就能让模型获得各模态的最新增强。
    
4. **可扩展性更强**
    
    有了一个能够处理多模态输入和多模态输出的通用框架，当面对新需求（如嵌入更多视觉检测、视频推断等任务）时，只要在当前模型上额外进行针对性调优，便可实现端到端的升级，而不会像过去那样要外接不同类型的新组件。
    

对于很多需要混合应用音视频处理、文档理解、实时通话协作的场景而言，Qwen2.5-Omni 带来的 “一体化协同” 让整个业务流程更为简洁：开发者不必再在多模态模型和单模态工具之间来回切换，维护起来也更加省时省力。对于希望构建通用 AI 服务的团队来说，这才是Omni类模型的价值所在。